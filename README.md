This repository demonstrates a common JavaScript closure issue encountered when using setTimeout within a loop. The bug.js file contains the faulty code, while bugSolution.js provides a corrected version.  The issue stems from the way closures capture variables. In the original code, the setTimeout callback function does not capture the value of 'i' at the time of its creation but rather captures a reference to the 'i' variable itself. This means that by the time the setTimeout callbacks finally execute, the loop has already completed, and 'i' will hold its final value (10).  The solution utilizes an immediately invoked function expression (IIFE) to create a new scope for each iteration, ensuring that each callback captures its own unique value of 'i'.